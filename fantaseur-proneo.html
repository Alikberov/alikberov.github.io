<!doctype html>
<html itemscope='' itemtype='http://schema.org/SearchResultsPage'	lang='ru'	  >
<head											  >
<meta content='text/html; charset=UTF-8'		http-equiv='Content-Type'	 />
<meta content='ru-RU'					http-equiv='Content-Language'	 />
<meta content='canvas,cartoon,comic,comics,comix,dream,fantasy,scenary'	name='keywords'	 />
<meta content='Static'							name='googlebot' />
<meta content='NoIndex,NoArchive'					name='Robots'	 />
<meta content='http://github.com/Alikberov'				name='Author'	 />
<meta description='Fantaseur-Scenarist'							 />
<meta http-equiv=refresh content='330'							 />
<title>Fantaseur-scripting</title>
<style>
body	{
	padding		:0px 0px 0px 0px;
	margin		:0px 0px 0px 0px;
	background-color:black;
}
a	{
	border		:blue thin outset;
}
pre#leds{
	background-color:grey;
}
td.operator	{
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_1	{
	background-color:yellow;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_2	{
	background-color:cyan;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_3	{
	background-color:magenta;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
textarea{
	font-family	:"Courier New";
	font-size	:12px;
}
</style>
<!--script type="text/javascript" src="../github/chiptune.js-master/libxmp.js"></script>
<script type="text/javascript" src="../github/chiptune.js-master/chiptune.js"></script-->
<script type="text/javascript" src="https://rawgithub.com/deskjet/chiptune.js/master/libxmp.js"></script>
<script type="text/javascript" src="https://rawgithub.com/deskjet/chiptune.js/master/chiptune.js"></script>
<!--
<script type='text/javascript' src='https://mod.haxor.fi/js/player.js'></script>
<script type='text/javascript' src='https://mod.haxor.fi/js/pt.js'></script>
<script type='text/javascript' src='https://mod.haxor.fi/js/st3.js'></script>
<script type='text/javascript' src='https://mod.haxor.fi/js/ft2.js'></script>
<script type='text/javascript' src='https://mod.haxor.fi/js/ui.js'></script>
-->
<script>//Symbol";
// http://www.onlinemictest.com/webcam-test/
// chrome.exe --user-data-dir="D:/dmp/Chrome" --disable-web-security --use-fake-device-for-media-stream --use-file-for-fake-video-capture="D:\dmp\Chrome\fake.y4m"
// http://xiph-media.net/video/derf/y4m/

//////////////////////////////////////////////////////////////////////////////
var	Audio	= {
		context	:null
	,	player	:null
	,	play	:function() {}
	,	stop	:function() {}
	,	load	:function() {}
	};

function Music(path, haxor) {
	if(haxor) {
		window.musicPath = "https://mod.haxor.fi/mods/";
		window.musicLibrary = [];
		window.currentModule = "https://mod.haxor.fi/mods/Groo/mod.electrification";
		window.defaultComposer = "";
		window.module=new Modplayer();
		//  window.module.context.resume();
		window.playlistPosition=0;
		window.playlistActive=false;
		window.module.load(path.replace(/^\/\//, "http:$1"));//window.currentModule);
		window.module.onReady = function() { window.module.play(); }
	} else {
	}
}

function initMusic() {
	// support webkit-prefix for chrome (and friends)
	if(undefined !== window.webkitAudioContext)
		AudioContext = webkitAudioContext;
	// support moz-prefix for Firefox (and friends)
	if(undefined !== window.mozAudioContext)
		AudioContext = mozAudioContext;
	{
		Audio.context = new AudioContext();
		Audio.player = new ChiptunePlayer(Audio.context.destination);
		Audio.autoPlay = function() {
			Audio.player.play(context = Audio.context);
		};
		Audio.play = Audio.player.play;
		Audio.stop = Audio.player.stop;
		Audio.load = function(file) { this.player.load(file, false, Audio.autoPlay) };
	}
}

/****************************************************************
setTimeout(Actor["ПОГОДА"](), 
****************************************************************/
//////////////////////////////////////////////////////////////////////////////
// "JohnDoe".toName() == "John Doe"
String.prototype.toName = function() { return this.replace(/([A-ZА-ЯЁ][a-zа-яё]*)(?:\.)/g, " $1").trim().split(/\s+/).join(""); };
// "wAneSsa".toNick() == "Wanessa"
String.prototype.toNick = function() { return this.charAt(0).toUpperCase() + this.substr(1).toLowerCase(); };
//////////////////////////////////////////////////////////////////////////////
// "Jo.D.".isNickOf([...]) == "JohnDoe"
String.prototype.isNickOf =
function(troupe) {
	var	id, name;
	var	a, b, c;
	name = this.replace(/([A-ZА-ЯЁ][a-zа-яё]*)(?:\.)/g, " $1").trim().split(/\s+/);
	id = name.join("");
	if(id in troupe)
		return id;
	for(id = 0; id < name.length; ++ id)
		name[id] = name[id].toNick();
	id = name.join("");
	if(id in troupe)
		return id.join("");
	for(id in troupe) {
		a = id.indexOf(name[0]);
		if(a >= 0) {
			if(name.length > 1) {
				b = id.indexOf(name[1], a);
				if(b >= 0) {
					if(name.length > 2) {
						c = id.indexOf(name[2], b);
						if(c >= 0)
							return id;
						else
							continue;
					}
					else
						return id;
				} else
					continue;
			}
			return id;
		}
	}
	return false;
};
//////////////////////////////////////////////////////////////////////////////
// Read the TextArea string
HTMLTextAreaElement.prototype.readString =
function(back) {
	//IE support
	if(document.selection) {
		this.focus();
		sel = document.selection.createRange();
		sel.text = szChar;
	} else
	//MOZILLA and others
	if(this.selectionStart || this.selectionStart == "0") {
		var	text	= this.value;				// Text of element
		var	start	= this.selectionStart;			// Cursor position
		var	end	= this.selectionEnd;			// Selection end
		var	lines	= text.split(/\r?\n/);			// Lines of text
		var	chop	= text.substr(0, start).split(/\r?\n/);	// Chopped text
		var	row	= chop.length;				// Index of current row
		var	column	= chop.pop().length;			// Index of column
		if(row <= lines.length) {
			if(!column)
				++ column;
			this.selectionStart = lines.slice(0, (back ? row - 2 : row)).join("\n").length + column;
			this.selectionEnd = this.selectionStart;
			return	lines[row - 1];
		}
		return null;
	} else
		this.value += szChar;
};
//////////////////////////////////////////////////////////////////////////////
var	Environment = {};
var	clouds	= [];/*{
		x	:320,	// cloud position
		y	:25,	// cloud position
		z	:0,	// cloud farness
		w	:20,	// cloud width
		h	:5,	// cloud height
		n	:7,	// cottons number
		r1	:2,	// noise factor
		r2	:10,	// fitness factor
		r3	:20,	// fatness factor
		x1	:0,	// drugness factor
		y1	:0,	// drugness factor
	}];*/

function actor_cloud_new(w, h, rainy) {
	return {
		x	:(Math.random() + 1) * w * 1,
		y	:(Math.random() + 1) * h / 10,
		z	:Math.random() * 5,
		w	:w / 6,
		h	:h / 48,
		n	:7,
		d	:rainy,
		r1	:5,
		r2	:10,
		r3	:20,
		x1	:0,
		y1	:0
	};
};
CanvasRenderingContext2D.prototype.cloud_create =
function(rainy, lighting) {
	return {
		x	:Math.random() * this.canvas.width,
		y	:Math.random() * this.canvas.height / 10,
		z	:Math.random() * 0+1,
		sailing	:1,
		leaving	:.1,
		obese	:(Math.random() + 1) * this.canvas.width / 12,
		curls	:Math.floor(Math.random() * 5) + 7,
		stormy	:rainy,
		lighting:lighting,
		tender	:5,
		dimple	:10,
		bubble	:20,
		text	:""//\tСегодня утром идёт дождь\tи дети прыгают по лужам"
	};
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.ellipse =
function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
	this.save(); this.translate(x, y); this.rotate(rotation); this.scale(radiusX, radiusY);
	this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
	this.restore();
};
//////////////////////////////////////////////////////////////////////////////
// Draw the cloud
CanvasRenderingContext2D.prototype.cloud =
function(cloud, blobs) {
	var	width, height, curls, faraway;
	var	font, rows, size, tail, text, author;
	var	tender, dimple, bubble;
	var	angle, turning, sprain;
	var	knot, knots = [];
	var	cx, cy, ascend;
	var	x1, y1;
	var	i, n;
	var	tmp;
	faraway = 1;
	text = cloud.text.length > 0 ? cloud.text.split(/\t+/) : [];
	tail = 0;
	this.save();
	if(text.length > 0) {
		author = text.shift().replace(/((?:\s*)[A-ZА-ЯЁ])/g, " $1").trim();
		text = text.join("\t");
		while(text.match(/(\(.*\))/))
			text = text.substr(1, text.length - 1),
			tail ++;
		text = text.split(/\t/);
		font = this.font;
		width = 0;
		for(rows = 0; rows < text.length; ++ rows) {
			size = this.measureText(text[rows]).width;
			if(width < size)
				width = size;
		}
		size = parseInt(font, 10);
		height = rows * size;
		angle = Math.PI / 4;
		width /= Math.sin(angle) * 2;
		height /= Math.cos(angle) * 2;
		curls = Math.floor(Math.sqrt(width + height));
		tender = 5,
		dimple = 10,
		bubble = 20;
/*		if(cloud.x < width / 2)
			cloud.x = width / 2,
			cloud.sailing = Math.abs(cloud.sailing);
		else
		if(cloud.x > this.canvas.width - width / 2)
			cloud.x = this.canvas.width - width / 2,
			cloud.sailing = -Math.abs(cloud.sailing);*/
		cx = cloud.x, cy = cloud.y;
		if(cloud.x - width < 0)
			cx = width,
			cloud.sailing = Math.abs(cloud.sailing);
		else
		if(cloud.x + width > this.canvas.width)
			cx = this.canvas.width - width,
			cloud.sailing = -Math.abs(cloud.sailing);
		var b, bw = width + bubble, bh = height + bubble;
		var dx, dy, dr, dr1, dr2;
		for(tmp in blobs) {
			b = blobs[tmp];
			dx = cx - b.x, dy = cy - b.y;
			dr = Math.sqrt(dx * dx + dy * dy);
			dr1 = Math.sqrt(b.w * b.w + b.h * b.h);
			dr2 = Math.sqrt(bw * bw + bh * bh);
			if(dr < (dr1 + dr2))
				cy += ((dr1 + dr2) - dr) * 4 / 9 * (Math.abs(dy) / dy);
		}
		blobs.push({x: cx, y: cy, w: width, h: height});
	} else
		faraway += Math.log(1 + Math.abs(cloud.z)),
		width = cloud.obese / faraway,
		height = this.canvas.height / 48 / faraway,
		curls = cloud.curls,
		tender = cloud.tender / faraway,
		dimple = cloud.dimple / faraway,
		bubble = cloud.bubble / faraway,
		cx = cloud.x, cy = cloud.y;
	turning = 2 * Math.PI / curls;
	sprain = turning / 3;
	angle = -turning;
	for(i = 0; i < curls; ++ i) {
		angle += turning + (Math.random() * 2 - 1) * sprain / curls;
		tmp = (angle * 180 / Math.PI + 360 + 60) % 360 > 90 ? 1 : 2 / 3;
		knots.push({
			x1: Math.sin(angle + sprain) * (width + bubble * tmp + Math.random()),
			y1: Math.cos(angle + sprain) * (height + bubble * tmp + Math.random()),
			x2: Math.sin(angle + sprain*2) * (width + bubble * tmp + Math.random()),
			y2: Math.cos(angle + sprain*2) * (height + bubble * tmp + Math.random()),
			x3: Math.sin(angle + sprain*3) * (width + dimple + Math.random()),
			y3: Math.cos(angle + sprain*3) * (height + dimple + Math.random())
		});
	}
	this.beginPath();
	if(text.length > 0 && author != "") {
		this.fillStyle = "rgba("+[Math.floor(255/(cloud.stormy/5+1)),Math.floor(255/(cloud.stormy/4+1)),255].join(",")+",1)";
		this.strokeStyle = "blue";
		this.lineWidth = 3 / faraway;
		y1 = cy + knots[knots.length - 1].y2 + (cloud.z - cy) / 2;
		x1 = knots[0].x1;
		if(tail > 0) {
			ascend = (cloud.z - cy + height) / tail,
			cy += ascend * (tail - 1);
			this.moveTo(cx + knots[knots.length - 1].x3 / tail, cy + knots[knots.length - 1].y3 / tail);
		} else {
			this.moveTo(cloud.x, cloud.z);
			ascend = 0;
		}
		n = 1 + tail;
	} else {
		this.fillStyle = "rgba("+[Math.floor(255/(cloud.stormy/5+1)),Math.floor(255/(cloud.stormy/4+1)),255].join(",")+",1)";
		this.strokeStyle = "blue";
		this.lineWidth = 3 / faraway;
		this.moveTo(cx + knots[i - 1].x3, cy + knots[i - 1].y3);
		n = 1; ascend = 0;
	}
	while(n > 0) {
		for(i = 0; i < knots.length; ++ i) {
			knot = knots[i];
			this.bezierCurveTo(cx + knot.x1 / n, cy + knot.y1 / n, cx + knot.x2 / n, cy + knot.y2 / n, cx + knot.x3 / n, cy + knot.y3 / n);
		}
		this.closePath();
		if(n > 1)
			this.fillStyle = "rgba(255,255,255," + (2 / n) + ")";
		this.fill();
		if(-- n > 0) {
			cy -= ascend;
			this.beginPath();
			this.moveTo(cx + knot.x3 / n, cy + knot.y3 / n);
		}
	}
	this.stroke();
	if(cloud.stormy > 10) {		// Rain
		this.strokeStyle = "rgba(64,160,255," + Math.abs(cloud.stormy/100) + ")";
		this.lineWidth = 2 / faraway;
		for(i = -5; i < 5; ++ i) {
			this.setLineDash([Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)
				//	, Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)
				//	, Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)
					, Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)]);
			x1 = Math.random() + cx + width * i / 5;
			this.beginPath();
			this.moveTo(x1, cy + height + Math.random() * height),
			this.lineTo(x1 - 5 * cloud.sailing, this.canvas.height);
			this.stroke();
		}
	} else
	if(cloud.stormy < 0) {		// Snow
		this.strokeStyle = "rgba(255,255,255," + Math.abs(cloud.stormy/100) + ")";
		this.lineWidth = 20 / faraway;
		for(i = -5; i < 5; ++ i) {
			this.setLineDash([Math.floor(Math.random() * 10), 5 + Math.floor(Math.random() * 10)
				//	, Math.floor(Math.random() * 10), 5 + Math.floor(Math.random() * 10)
				//	, Math.floor(Math.random() * 10), 5 + Math.floor(Math.random() * 10)
					, Math.floor(Math.random() * 10), 5 + Math.floor(Math.random() * 10)]);
			x1 = Math.random() + cx + width * i / 5;
			this.beginPath();
			this.moveTo(x1, cy + height + Math.random() * height),
			this.lineTo(x1 - 5 * cloud.sailing, this.canvas.height);
			this.stroke();
		}
	}
	if(text.length > 0) {
		if(author)
			text.unshift(author),
			this.font = "bold " + font;
		else
			this.font = "italic " + font;
		cy -= (text.length - 1) * size / 2;
		for(i = 0; i < text.length; ++ i) {
			this.fillStyle = !i && author ? "magenta" : "black";
			this.beginPath();
			this.fillText(text[i], cx - this.measureText(text[i]).width / 2, cy);
			cy += size;
			if(author)
				this.font = font;
			this.stroke();
		}
		this.font = font;
		cy = cloud.z > 0 ? size * text.length * 7 : -size * text.length * 2;
		if(!author) {
			cloud.x += cloud.sailing;
			cloud.y += (cy - cloud.y) / (cy > 0 ? 5 : 29);
			if(cloud.z > 0 && (cy - cloud.y) < 10)
				cloud.z = -cloud.z;
			if(cloud.z < 0)
				cloud.z ++;
		}
	} else
		cloud.x += cloud.sailing / faraway,
		cloud.z += cloud.leaving;
	this.restore();
};
//////////////////////////////////////////////////////////////////////////////
//
CanvasRenderingContext2D.prototype.horizon = {
	hl	:-320,	// Horizon Left point
	hr	:+320,	// Horizon Right point
	hc	:256,	// Horizon vertical Center
	hd	:100,	// Horizon Deep
	xyz	:
	function(x, y, z) {
		var	dz = z / this.horizon.hd;
		return {
			xl	:0
		}
	}
};
CanvasRenderingContext2D.prototype.horizont = {
	vx1	:0,
	vy1	:0,
	vx2	:640,
	vy2	:480,
	vz	:-80,
	wx	:320,
	wy	:360,
	wz	:80
};
CanvasRenderingContext2D.prototype.xyz =
function(x, y, z) {
	var
		dx1 = this.horizont.wx - this.horizont.vx1,
		dy1 = this.horizont.wy - this.horizont.vy1,
		dz1 = this.horizont.wz - this.horizont.vz,
		dx2 = this.horizont.wx - this.horizont.vx2,
		dy2 = this.horizont.wy - this.horizont.vy2,
		dz2 = z - this.horizont.vz,
		dz = dz2 < 0 ? 1 : Math.pow(Math.log(Math.E - dz2 / dz1), 1),
		x1 = this.horizont.vx1 + dx1 / dz,// / dz1 * dz2,
		y1 = this.horizont.vy1 + dy1 / dz,// / dz1 * dz2,
		x2 = this.horizont.vx2 + dx2 / dz,// / dz1 * dz2,
		y2 = this.horizont.vy2 + dy2 / dz,// / dz1 * dz2,
		dx = (x - this.horizont.vx1) / (this.horizont.vx2 - this.horizont.vx1),
		dy = (y - this.horizont.vy1) / (this.horizont.vy2 - this.horizont.vy1);
	return {
		x	:x1 + (x2 - x1) * dx,
		y	:y1 + (x2 - x1) * dy
	}
};
var	zzz=0;
CanvasRenderingContext2D.prototype.hiway =
function() {
	var	xy1, xy2, xy3, xy4, i, zz;
	this.beginPath();
	this.moveTo(this.horizont.vx1, this.horizont.vy2);
	this.lineTo(this.horizont.wx, this.horizont.wy);
	this.lineTo(this.horizont.vx2, this.horizont.vy2);
	this.closePath();
	this.stroke();
	this.fill();
	zzz+=3;
	zz = (this.horizont.wz - this.horizont.vz) / 3;
	zzz%=zz;
	this.beginPath();
	for(i = this.horizont.wz+zzz; i >= this.horizont.vz-zz; i -= zz) {
		xy1 = this.xyz(this.canvas.width / 2 + this.canvas.width / 10, this.canvas.height*0, i);
		xy2 = this.xyz(this.canvas.width / 2 - this.canvas.width / 10, this.canvas.height*0, i);
		xy3 = this.xyz(this.canvas.width / 2 - this.canvas.width / 10, this.canvas.height*0, i + zz / 2);
		xy4 = this.xyz(this.canvas.width / 2 + this.canvas.width / 10, this.canvas.height*0, i + zz / 2);
		this.moveTo(xy1.x, xy1.y);
		this.lineTo(xy2.x, xy2.y);
		this.lineTo(xy3.x, xy3.y);
		this.lineTo(xy4.x, xy4.y);
		this.lineTo(xy1.x, xy1.y);
	}
	this.closePath();
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.house =
function(x, far, levels) {
return;
	var	w = this.canvas.width / 5;
	var	h = this.canvas.height / 6;
	var	z = Math.pow(far, 3);//Math.log(1 + Math.abs(far)) * 1.875;
	var	s = 10;
	var	y = this.canvas.height - h * s / z / 2;
	var	i, xy1, xy2;
	x = 320;
	//x = this.canvas.width / 2 + (x - this.canvas.width / 2) * z / s;
	y = this.canvas.height;
	for(i = 0; i < levels; ++ i) {
		this.beginPath();
		this.fillStyle = "yellow";
		this.strokeStyle = "red";
		this.lineWidth = 3;
		xy1 = this.xyz(x - w / 2, y, -z*80);
		xy2 = this.xyz(x + w / 2, y - h, -z*80);
		this.rect(xy1.x, xy1.y, xy2.x - xy1.x, xy2.y - xy1.y);
//		this.rect(x - w / 2 * z / s, y - h / 2 * z / s, w * z / s, h * z / s);
		this.stroke();
		this.fill();
		y -= h;
	}
	this.beginPath();
/*	this.moveTo(x - w / 2 / z, y + h / 2 / z);
	this.lineTo(x, y - h / 2 / z);
	this.lineTo(x + w / 2 / z, y + h / 2 / z);
*/	this.closePath();
	this.stroke();
	this.fill();
}
//////////////////////////////////////////////////////////////////////////////
// 
// облако, позиция, ветер, капли текст голова небо
CanvasRenderingContext2D.prototype.cloud_old =
function(cloud, x0, windy, d, text, xm, ym, yy, blobs) {
	var	x, y, z, w, h, n, d, r1, r2, r3;
	var	x1, y1, x2, y2, x3, y3, r, r0, tmp;
	var	a, a0, a1, a2, a3, i, j, k, arr = [];
	var	tx, ty, tw = 0, th, tl = 0, rx, ry;
	var	cx, cy, cz, cn = 1;
	var	bx, by, bw, bh;
	var	b, dx, dy, dr, dr1, dr2;
	var	thought = false;
	if(text) {
		thought = text.slice(1).join().match(/(\(.*\))/);
		while(text.slice(1).join().match(/(\(.*\))/))
			cn ++,
			text[1] = text[1].substr(1),
			text[text.length - 1] = text[text.length - 1].substr(0, text[text.length - 1].length - 1);
		text[0] = text[0].replace(/((?:\s*)[A-ZА-ЯЁ])/g, " $1").trim();
		th = parseInt(this.font, 10);
		for(h = 0; h < text.length; ++ h) {
			w = this.measureText(text[h]).width;
			if(tw < w)
				tw = w;
			if(tl < text[h].length)
				tl = text[h].length;
		}
		x = xm, y = yy, z = 1;
		w = tw / Math.sin(Math.PI / 4) / 2;
		n = Math.floor(tl);
		h = th / Math.cos(Math.PI / 4) / 2 * (h + 0) / (thought ? 1 : 1);;
		r1 = 2, r2 = 10, r3 = 20;
		r2 = 5, r3 = 13;
	} else {
		cloud.x1 += Math.random() * windy / 10 + windy / 5;
		cloud.y1 += Math.random() * windy / 10 + windy / 5;
		cloud.x1 = cloud.x1 % (windy / 5 + 1), cloud.y1 = cloud.y1 % (windy / 5 + 1);
		x = cloud.x + cloud.x1, y = cloud.y + cloud.y1, z = 1 + Math.log(cloud.z + 1);
		w = cloud.w / z, h = cloud.h / z, n = cloud.n;
		r1 = cloud.r1 / z, r2 = cloud.r2 / z, r3 = cloud.r3 / z;
		cloud.x -= windy / z;
		cloud.z += 1/5;
	}
	x += x0;
	a0 = 2 * Math.PI / n;
	a1 = a0 / 3;
	a2 = a0 / 3 + a1;
	a3 = a0 / 3 + a2;
	a = -a0;
	bw = w + r3,
	bh = h + r3;
	for(i = 0; i < n; ++ i) {
		a += a0 + (Math.random() * 2 - 1) * a3 / n;
		arr.push({
			x1: Math.sin(a + a1) * (w + r3 + Math.random()),
			y1: Math.cos(a + a1) * (h + r3 + Math.random()),
			x2: Math.sin(a + a2) * (w + r3 + Math.random()),
			y2: Math.cos(a + a2) * (h + r3 + Math.random()),
			x3: Math.sin(a + a3) * (w + r2 + Math.random()),
			y3: Math.cos(a + a3) * (h + r2 + Math.random())
		});
	}
	i = Math.floor(n / 4); j = i + 1;
	arr[i].x2 = arr[j].x2, arr[i].y2 = arr[j].y2;
	arr[i].x3 = arr[j].x3, arr[i].y3 = arr[j].y3;
	arr.splice(j, 1);
	i = Math.floor(arr.length - arr.length / 4); j = i + 1;
	arr[i].x2 = arr[j].x2, arr[i].y2 = arr[j].y2;
	arr[i].x3 = arr[j].x3, arr[i].y3 = arr[j].y3;
	arr.splice(j, 1);
	this.beginPath();
	this.fillStyle = "white";
	this.strokeStyle = "white";
	this.closePath();
	this.stroke();
	this.beginPath();
	this.fillStyle = "rgba("+[Math.floor(255/(d/5+1)),Math.floor(255/(d/4+1)),255].join(",")+",1)";
	this.lineWidth = 3 / z;
	n = arr.length - 1;
	cx = x, cy = y, cz = 0;
	if(text) {
		cy = yy;
		if(cx - w < 0)
			cx = w;
		else
		if(cx + w > this.canvas.width)
			cx = this.canvas.width - w;
		for(tmp in blobs) {
			b = blobs[tmp];
			dx = cx - b.x, dy = cy - b.y;
			dr = Math.sqrt(dx * dx + dy * dy);
			dr1 = Math.sqrt(b.w * b.w + b.h * b.h);
			dr2 = Math.sqrt(bw * bw + bh * bh);
			if(dr < (dr1 + dr2))
				cy += ((dr1 + dr2) - dr) * 4 / 9;
		}
		if(thought) {
			this.setLineDash([]);
			y1 = cy + arr[n].y2 + (ym - cy) / 2;
			x1 = arr[0].x1;
			cz = (ym - cy + h) / cn;
			cy += cz * (cn - 1);
			this.moveTo(cx + arr[n].x3 / cn, cy + arr[n].y3 / cn);
		} else
			this.setLineDash([3,2,1,2]),
			this.moveTo(xm, cy + (ym - cy) * 7 / 7);
		bx = cx, by = cy;
	} else
		this.moveTo(cx + arr[n].x3, cy + arr[n].y3);
	while(cn > 0) {
		for(i = 0; i < arr.length; ++ i) {
			tmp = arr[i];
			this.bezierCurveTo(cx + tmp.x1 / cn, cy + tmp.y1 / cn, cx + tmp.x2 / cn, cy + tmp.y2 / cn, cx + tmp.x3 / cn, cy + tmp.y3 / cn);
		}
		this.closePath();
		if(cn > 1)
			this.fillStyle = "rgba(255,255,255," + (2 / cn) + ")";
		this.fill();
		if(-- cn > 0) {
			cy -= cz;
			this.beginPath();
			this.moveTo(cx + tmp.x3 / cn, cy + tmp.y3 / cn);
		}
	}
	this.strokeStyle = '#0000ff';
	this.stroke();
	this.beginPath();
	this.strokeStyle = "rgba(64,160,255," + (d/100) + ")";
	this.lineWidth = 2 / z;
	if(d > 10) {
		for(i = 0; i < 10; ++ i) {
			this.setLineDash([Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)]);
			x1 = Math.random() + x + w * i / 10;
			//if(Math.random() * d > i / 2)
				this.moveTo(x1, y + h + Math.random() * h),
				this.lineTo(x1 + 1 * windy, this.canvas.height);
		}
	}
	this.stroke();
	this.setLineDash([]);
	if(text) {
		tx = cx, ty = cy - (text.length - 1) * th / 2;
		tmp = this.font;
		this.font = "bold " + tmp;
		for(i = 0; i < text.length; ++ i) {
			j = i < 0 ? 0 : i;
			this.fillStyle = i < 0 ? "black" : i ? "black" : "magenta";
			this.beginPath();
			this.fillText(text[j], tx - this.measureText(text[j]).width / 2, ty);
			if(i >= 0)
				ty += th + Math.random() * 2,
				this.font = tmp;
			else
				tx += 2 - Math.random() * 3;
			this.stroke();
		}
		blobs.push({x: bx, y: by, w: bw, h: bh});
	}
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.face =
function(x, y, width, height, rotation, emoji, eyes) {
	var	tmp;
	this.beginPath();
	this.save(); this.translate(x, y); this.rotate(rotation); this.scale(width, height);
	this.arc(0, 0, 1, 0, Math.PI * 2, false); this.restore();
	this.stroke(); this.fill();
	if(emoji) {
		tmp = Math.random() * 100 > 95 ? 0.125 : 1;
		this.save(); this.translate(x, y); this.rotate(rotation);
		this.lineWidth = 6 / 5;
		this.strokeStyle = "white", this.fillStyle = eyes;
		this.beginPath();						// Draw the left eye
		this.ellipse(-width * 3 / 7, -height / 3, emoji.lRadius * 3 / 2, emoji.lHeight * tmp * 3 / 2, 0, emoji.lStart * Math.PI / 180, emoji.lFinal * Math.PI / 180, true);
		this.closePath(); this.stroke(); this.fill(); this.beginPath();	// Draw the right eye
		this.ellipse(+width * 3 / 7, -height / 3, emoji.rRadius * 3 / 2, emoji.rHeight * tmp * 3 / 2, 0, emoji.rStart * Math.PI / 180, emoji.rFinal * Math.PI / 180, true);
		this.closePath(); this.stroke(); this.fill(); this.beginPath();	// Draw the mouth
		this.ellipse(0, height * 5 / 9, emoji.mRadius * 1, emoji.mHeight, 0, emoji.mStart * Math.PI / 180, emoji.mFinal * Math.PI / 180, true);
		this.closePath();
		this.strokeStyle = "red", this.fillStyle = "red";
		this.stroke();
		this.restore();
	}
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.kinematic_line =
function(x1, y1, x3, y3, limit, vx, vy) {
	var	dx = x3 - x1, dy = y3 - y1;
	var	len = Math.max(Math.abs(dx), Math.abs(dy)), rad;
	if(len >= 2 * limit) {
		this.lineTo(x1 + 2 * dx / len * limit, y1 + 2 * dy / len * limit);
		return {x:x1 + 2 * dx / len * limit, y:y1 + 2 * dy / len * limit};
	}
	x2 = x1 + dx / 2, y2 = y1 + dy / 2;
	rad = Math.sqrt(dx * dx + dy * dy) / 2;
	rad = Math.sqrt(limit * limit - rad * rad);
	x2 += vx * dy / len * rad, y2 += vy * dx / len * rad;
	this.lineTo(x2, y2); this.lineTo(x3, y3);
	return {x:x3, y:y3};
};

function newMan() {
	return {
		position:{
			x	:0,	// Позиция относительно центра
			y	:0,
			z	:1,	// Расстояние от центра
			j	:21	// Jumping amplitude
		},
		members:{
			lHandX	:-10,	// Left Hand X
			lHandY	:10,	// Left Hand Y
			rHandX	:10,
			rHandY	:20,
			lFootX	:0,
			lFootY	:0,
			rFootX	:0,
			rFootY	:0,
		},
		colours:{
			head	:"grey",
			face	:"yellow",
			body	:"magenta",
			eyes	:"darkcyan"
		},
		path:{
			points	:[],
			seek	:10
		},
		chatArea	:null,
		playing		:null,
		// is speaking?
		"говорит?":function() { return this.text.join("").length > 2; },
		// is quiet?
		"молчит?":function() { return this.text.join("").length <= 2; },
		// is jumping?
		"прыгает?":function() { return this.j > 0; },
		// is jumped?
		"прыгнул?":function() { return this.j > 0 && this.phase < (this.step + (this.step > 180 ? -180 : this.step > -180 ? +180 : +540)) % 360; },
		// is steping?
		"шагает?":function() { return this.step < -180 || this.step > 180; },
		// is stepped?
		"шагнул?":function() { return (this.step < -180 || this.step > 180) && this.phase < (this.step + (this.step > 180 ? -180 : this.step > -180 ? +180 : +540)) % 360; },
		// let stay
		"стоит":function() { return (this.step = 0, this.position.j = 0) && false; },
		// let jumping
		"прыгает":function() { (this.position.j = 125.0009); return false; },
		// let walking
		"шагает":function() { return (this.step = 30) && false; },
		// let running
		"бежит":function() { return (this.step = 60) && false; },
		// to back
		"обратно":function() { return (this.step = -this.step) && false; },
		// let moving
		"движется":function() { return (this.step += 180) && false; },
		// quickly
		"быстрее":function() { return (this.step += this.step > 0 ? 10 : -10) && false; },
		// catching
		"ловит":function(target) { if(!target) return;
						this.members.lHandX = target.position.x;
						this.members.lHandY = target.position.y;
						this.members.rHandX = target.position.x;
						this.members.rHandY = target.position.y;
						return false;
					},
		// overtaking
		"догоняет":function(target) { if(!target) return;
						var dist = target.position.x - this.position.x;
						if(Math.abs(dist) > 64)
							this.step = dist < 0 ? -200 : +200;
						else
							this.step = 0;
					},
		// escaping
		"избегает":function(target) { if(!target) return;
						var dist = target.position.x - this.position.x;
						if(Math.abs(dist) < 500)
							this.step = dist < 0 ? +200 : -200;
						else
							this.step = 0;
					},
		// waiting
		"ждет":function(target) { return (target.text.length == 0) || (target.text[0] == ""); },
		// listing
		"слушает":function(target) { return (target.text.length > 1); },
		novel	:[],		// Текущая роль / Current actions
		text	:[],		// Реплика / Remark
		age	:16,		// Возраст персонажа
		fat	:100.0,		// Упитанность
		weight	:100.0,		// Вес
		suit	:"red",		// Цвет костюма
//		step	:+20,// Right
//		step	:-20,// Left
//		step	:+200,// Forward
//		step	:-200,// Backward
		step	:0,	// Текущая фаза шага: >540 - вперёд, <-540 - назад
		phase	:0
	};
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.parse_emotion =
function(emotion, size) {
	var	face_parts =	"lStart	lFinal	lRadius	lHeight	rStart	rFinal	rRadius	rHeight	mStart	mFinal	mRadius	mHeight".split(/[\s\t]+/);
	var	emotions = {
			":)":	"0	360	1/7	1/9	0	360	1/7	1/9	180	360	1/5	1/9"
		,	":-D":	"0	180	1/7	1/9	0	180	1/7	1/9	180	360	1/5	1/6"
		,	":(":	"0	360	1/7	1/9	0	360	1/7	1/9	0	180	1/5	1/9"
		,	":o":	"0	360	1/6	1/8	0	360	1/6	1/8	0	360	1/5	1/6"
		};
	var	members, id, data;
	var	result = {};
	if(emotion in emotions) {
		members = emotions[emotion].split(/[\s\t]+/);
		for(id in face_parts)
			data = members.shift().split(/\//),
			result[face_parts[id]] = data.length > 1 ? size * +data[0] / +data[1] : +data[0];
		return result;
	}
	return null;
};
//////////////////////////////////////////////////////////////////////////////
// 
CanvasRenderingContext2D.prototype.stickMan =
function(man, clouds) {
	var	far = Math.log((man.position.z + 1) / 2*2);						// Дальность
	var	fat = man.fat / 100;									// Упитанность
	var	stature = this.canvas.height / (man.age < 16 ? 8 - man.age / 3 : 3) / ((far / 4) + 1);	// Рост
	var	center = this.canvas.width / 2 + man.position.x;					// Центр оси
	var	jumphase = man.position.j * Math.PI * 2;						// Фаза прыжка
	var	jump = man.position.j > 0 ?
		(Math.abs(Math.sin(jumphase) * 2) - 1) * man.position.j * stature / 600
		: man.position.j * stature / 600;
	var	jumping = stature + jump;
	var	foot = this.canvas.height - man.position.y - far * jumping / 1.875;			// Позиция ступ		/ Foots position
	var	width = fat * stature / 5;								// Ширина головы	/ Head width
	var	head_x = center, head_y = foot - jumping * man.fat / man.weight + width / 2;		// Позиция головы	/ Head position
	var	head_width = width / 2, head_height = width / 2;					// Ширина/высота головы	/ Head width and height
	var	left_hand = center + fat * width / (man.step >= 180 ? 3 : 3 / 2);			// Позиция левой руки	/ Left hand position
	var	right_hand = center - fat * width / (man.step < -180 ? 3 : 3 / 2);			// Позиция правой руки	/ Right hand position
	var	hand_y = (foot - jumping * man.fat / man.weight) + width + jumping / 12;		// Позиция плеч		/ Shoulders position
	var	body_y = head_y + head_height + jumping / 3;						// Позиция тела		/ Body position
	var	emotion, offset, tmp, flag;
	var	a = man.step < -180 ? Math.PI / 9 : man.step > 180 ? -Math.PI / 9 : 0, b, c, dx, dy;
	var	text = [].concat(man.text);
	var	sine, cose;
	var	left, rift;
	for(tmp = 0; tmp < text.length; ++ tmp)
		if(emotion = this.parse_emotion(text[tmp], width))
			text.splice(tmp, 1);
		else
			continue;
	// Рисуем лицо / Draw the face
	this.save(); this.translate(head_x, head_y); this.scale(head_width, head_height); 
	this.beginPath(); this.arc(0, 0, 1, 0, Math.PI * 2, false); this.closePath(); this.restore();
	this.strokeStyle = man.colours.head; this.fillStyle = man.colours.face;
	this.stroke(); this.fill();
	this.face(head_x, head_y, head_width, head_height, a, emotion, man.colours.eyes);
	// Рисуем левый контур тела / Draw the left side of body
	this.beginPath(); this.lineWidth = (man.step >= 180 ? 1 : 2);
	this.moveTo(head_x, head_y + head_height); this.lineTo(left_hand, hand_y); this.lineTo(head_x, body_y);
	this.stroke();
	// Рисуем правый контур тела / Draw the right side of body
	this.beginPath(); this.lineWidth = (man.step < -180 ? 1 : 2);
	this.moveTo(head_x, head_y + head_height); this.lineTo(right_hand, hand_y); this.lineTo(head_x, body_y);
	this.stroke();
	// Закрашиваем тело / Painting the body
	this.beginPath(); this.fillStyle = man.colours.body;
	this.moveTo(head_x, head_y + head_height); this.lineTo(left_hand, hand_y);
	this.lineTo(head_x, body_y); this.lineTo(right_hand, hand_y); this.closePath(); this.fill();
	// Рисуем левую руку / Draw the left hand
	this.beginPath(); this.moveTo(left_hand, hand_y);
	this.kinematic_line(left_hand, hand_y, man.members.lHandX, man.members.lHandY, stature / 8, -1, +1);
	this.lineWidth = (man.step >= 180 ? 1 : 3); this.closePath(); this.stroke();
	// Рисуем правую руку / Draw the right hand
	this.beginPath(); this.moveTo(right_hand, hand_y);
	this.kinematic_line(right_hand, hand_y, man.members.rHandX, man.members.rHandY, stature / 8, +1, -1);
	this.lineWidth = (man.step < -180 ? 1 : 3); this.closePath(); this.fill();this.stroke();
	// Рисуем левую ногу / Draw the left leg
	this.beginPath(); this.moveTo(center, body_y);
	if(man.step < -180) {			// When walking back
		this.lineWidth = 3,		// Когда шагает назад
		offset = -width / 2,
		flag = +1;
	} else {
		if(man.step <= 180)		// When just walking
			offset = width * 3 / 4,	// Когда просто шагает
			this.lineWidth = 3;
		else				// When walking forward
			offset = width / 2,	// Когда шагает вперёд
			this.lineWidth = 1;
		flag = -1;
	}
	tmp = this.kinematic_line(center, body_y, man.members.lFootX + offset, man.members.lFootY, width, -flag, +flag);
	this.ellipse(tmp.x, tmp.y, width / 3, width / 5, (flag + 1) * Math.PI / 2, 0, Math.PI, flag > 0);
	this.stroke();
	// Рисуем правую ногу / Draw the right leg
	this.beginPath(); this.moveTo(center, body_y);
	if(man.step >= 180) {			// When walking forward
		this.lineWidth = 3,		// Когда шагает вперёд
		offset = width / 2,
		flag = -1;
	} else {
		if(man.step > -180)		// When just walking
			offset = -width * 3 / 4,// Когда просто шагает
			this.lineWidth = 3;
		else				// When walking back
			offset = -width / 2,	// Когда шагает назад
			this.lineWidth = 1;
		flag = +1;
	}
	tmp = this.kinematic_line(center, body_y, man.members.rFootX + offset, man.members.rFootY, width, -flag, +flag);
	this.ellipse(tmp.x, tmp.y, width / 3, width / 5, (flag + 1) * Math.PI / 2, 0, Math.PI, flag > 0);
	this.stroke();
	// Двигаем всего персонажа / Moving this personage
	if(man.path.seek >= 0 && man.path.seek < man.path.points.length) {
		a = Math.floor(man.path.seek);
		b = man.path.points[a];
		man.position.x = b.x - this.canvas.width / 2;
		man.position.z = b.y / 72;
		if(man.step < -180 || man.step > 180)
		do {
			a += man.step < -180 ? -1 : +1;
			tmp = a >= 0 && a < man.path.points.length;
			if(tmp) {
				c = man.path.points[Math.floor(a)];
				dx = c.x - b.x, dy = c.y - b.y;
				c = (man.step < -180 ? man.step + 180 : man.step - 180) % 360;
				tmp = Math.sqrt(dx * dx + dy * dy) < c / 8;
			}
		} while(tmp && false);
		man.path.seek = a;
	} else {
		man.position.x = man.step < -180 ? man.position.x + (man.step + 180) % 360 / 8 : man.step >= 180 ? man.position.x + (man.step - 180) % 360 / 8 : man.position.x;
	}
	left = man.step >= 540 ? man.phase + 180 : man.phase - 540;
	rift = man.step >= 540 ? man.phase + 180 + 180 : man.phase - 540 - 180;
	if(man.step > 180)
		man.phase = (man.phase + man.step - 180) % 360;
	else
	if(man.step < -180)
		man.phase = (man.phase + man.step + 180) % 360;
	else
		man.phase = (man.phase + man.step + 360) % 360;
	a = (left % 360 + 360) % 360;
	sine = a < 180 ? Math.sin(a * Math.PI / 180) : 0;
	cose = Math.cos(a * Math.PI / 180);
	man.members.lFootX = center - width / 3 * cose, man.members.lFootY = foot - width / 2 * sine;
	a = (rift % 360 + 360) % 360;
	sine = a < 180 ? Math.sin(a * Math.PI / 180) : 0;
	cose = Math.cos(a * Math.PI / 180);
	man.members.rFootX = center - width / 3 * cose, man.members.rFootY = foot - width / 2 * sine;
	man.members.lFootX = man.step < -180 ? man.members.lFootX + width / 3 : man.step >= 180 ? man.members.lFootX - width / 3 : man.members.lFootX;
	man.members.lFootY = man.members.lFootY - width / 6;
	man.members.rFootX = man.step < -180 ? man.members.rFootX + width / 3 : man.step >= 180 ? man.members.rFootX - width / 3 : man.members.rFootX;
	man.members.rFootY = man.members.rFootY - width / 6;
	a = Math.floor(man.position.j);
	b = Math.floor(man.position.j * 100);
	c = Math.floor(man.position.j * 10000);
	//man.position.j = a + Math.floor((man.position.j + man.position.j * 100) * 100) % 100 / 100 + c % 100 / 10000;
	man.position.j = a + (b + c) % 100 / 100 + c % 100 / 10000;
	if(text.length > 1) {
		//this.cloud([],0,0,0, [].concat(text), center, head_y - head_height * 2, 100, blobs);
		tmp = this.cloud_create(0, 0);
		tmp.x = center,
		tmp.y = 100,
		tmp.z = head_y - head_height * 2,
		tmp.text = text.join("\t");
		clouds.push(tmp);
	}
};
////////////////////////////////////////////////////////////////////////////////
function	Variation(tmp) {
	var	now = tmp[0], min = tmp[1], max = tmp[2], rnd = Math.random();
	if(min > max)
		return now - (now - (max + (min - max) / 5));
	if(now < min)
		return now + (max - now) * (rnd * 10) / 19;
	if(now > max)
		return now - (now - min) * (rnd * 10) / 19;
	return now - (now - (min + (max - min) * (rnd * 10) / 10)) / 10;
}
function Acting(This, Man) {
	var	tmp = Man.role;
	while(tmp.length) {
		if(tmp[0][0] == "@") {
			tmp[0][0] = "";
			setTimeout(This.Next.bind(This, Man), Variation([tmp[0][1], tmp[0][1], tmp[0][2]]) * 1000);
		} else
		if(tmp[0][1] != "" && (tmp[0][1] in This)) {
			Man.acts.push([tmp[0][1], tmp[0][2]]);
			tmp.shift();
			continue;
		} else
		if(tmp[0][0] != "" && (tmp[0][0] in This)) {
			if(tmp[0][1] < 0)
				This[tmp[0][0]][0] = tmp[0][2];
			else
				This[tmp[0][0]][1] = tmp[0][1],
				This[tmp[0][0]][2] = tmp[0][2];
			tmp.shift();
			continue;
		}
		return;
	}
}
//////////////////////////////////////////////////////////////////////////////
var	ways	= [{
		path	:"ss--^^^^-|Улица Гоголя|--z----------------------"
	}];
CanvasRenderingContext2D.prototype.bezierCurveToArray =
function(points, x1, y1, x2, y2, x3, y3, x4, y4, accuracy, text) {
	var	x, y, ox, oy, t = 0;
	var	s = 1 / 100, d;
	do {
		x	= Math.pow(1 - t, 3) * Math.pow(3, 0) * Math.pow(t, 0) * x1
			+ Math.pow(1 - t, 2) * Math.pow(3, 1) * Math.pow(t, 1) * x2
			+ Math.pow(1 - t, 1) * Math.pow(3, 1) * Math.pow(t, 2) * x3
			+ Math.pow(1 - t, 0) * Math.pow(3, 0) * Math.pow(t, 3) * x4;
		y	= Math.pow(1 - t, 3) * Math.pow(3, 0) * Math.pow(t, 0) * y1
			+ Math.pow(1 - t, 2) * Math.pow(3, 1) * Math.pow(t, 1) * y2
			+ Math.pow(1 - t, 1) * Math.pow(3, 1) * Math.pow(t, 2) * y3
			+ Math.pow(1 - t, 0) * Math.pow(3, 0) * Math.pow(t, 3) * y4;
		if(t > 0) {
			d = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2));
			if(d > accuracy + 1) {
				t -= s;
				s -= 1 / 100;
				t += s;
				continue;
			}
			if(d < accuracy - 1) {
				t += s;
				continue;
			}
		}
		points.push({
			x: ox = x,
			y: oy = y,
			text: text
		});
		text = "";
		t += s;
		s = 1 / 100;
	} while(t <= 1);
}
CanvasRenderingContext2D.prototype.bezierCurveToArray_old =
function(points, x1, y1, x2, y2, x3, y3, x4, y4, accuracy, text) {
	var	xa, ya, xb, yb, xc, yc, xp, yp;
	var	xx1, yy1, xx2, yy2, xx3, yy3;
	var	dx1, dy1, dx3, dx3;
	var	dx2, dy2, dx, dy;
	var	l12, l23, l34, len;
	var	tmp, i, s;
	dx1 = x2 - x1, dy1 = y2 - y1;
	dx2 = x3 - x2, dy2 = y3 - y2;
	dx3 = x4 - x3, dy3 = y4 - y3;
	l12 = Math.abs(dx1); tmp = Math.abs(dy1); l12 = tmp > l12 ? tmp : l12;
	l23 = Math.abs(dx2); tmp = Math.abs(dy2); l23 = tmp > l23 ? tmp : l23;
	l34 = Math.abs(dx3); tmp = Math.abs(dy3); l34 = tmp > l34 ? tmp : l34;
	len = l12 > l23 ? l12 > l34 ? l12 : l34 : l23 > l34 ? l23 : l34;
	dx1 /= len, dy1 /= len;
	dx2 /= len, dy2 /= len;
	dx3 /= len, dy3 /= len;
	for(i = 0; i < len; i += s) {
		xx1 = x1 + dx1 * i, yy1 = y1 + dy1 * i;
		xx2 = x2 + dx2 * i, yy2 = y2 + dy2 * i;
		xx3 = x3 + dx3 * i, yy3 = y3 + dy3 * i;
		xa = xx1 + i * (xx2 - xx1) / len, ya = yy1 + i * (yy2 - yy1) / len;
		xb = xx2 + i * (xx3 - xx2) / len, yb = yy2 + i * (yy3 - yy2) / len;
		xc = xa + i * (xb - xa) / len, yc = ya + i * (yb - ya) / len;
		if(i > 0) {
			dx = xc - xp, dy = yc - yp;
			// Если между точками промежуток велик, шагаем обратно
			if(Math.sqrt(dx * dx + dy * dy) > accuracy + 1) {
				i -= s;
				s /= 2;
				continue;
			}
			// Если между точками промежжуток мал, игнорируем
			if(Math.sqrt(dx * dx + dy * dy) < accuracy - 1)
				continue;
		}
		s = 1;
		points.push({
			x	:(xp = xc),
			y	:(yp = yc),
			text	:text
		});
		text = "";
	}
};
CanvasRenderingContext2D.prototype.build_way =
function(way) {
	var	points = [];
	var	x1, y1, x2, y2, x3, y3, x4, y4;
	var	dx, dy, dz;
	var	p = way.path.split("");
	var	a, c;
	var	t = false, text = "";
	dx = this.canvas.width / 8;
	dy = -72;
	dz = dx / 2;
	x1 = -dx, y1 = 2;
	while(p.length > 0) {
		a = 3, c = p.shift();
		if('|' == c) {
			t = !t;
			if(t)
				text = "";
			continue;
		}
		if(t) {
			text += c;
			continue;
		}
		switch(c) {
		case '-':
			x2 = x1,
			y2 = y1,
			x4 = x1 + dx,
			y4 = y1 + 0,
			x3 = x4,
			y3 = y4;
			break;
		case '^':
			x2 = x1 + 0,
			y2 = y1 - 0,
			x4 = x1 + dx * 0,
			y4 = y1 - dy / 2,
			x3 = x4 + 0,
			y3 = y4 + 0;
			a = 12;
			break;
		case 's':
			x2 = x1 + dz,
			y2 = y1 + 0,
			x4 = x1 + dx,
			y4 = y1 - dy / 2,
			x3 = x4 - dz,
			y3 = y4 - 0;
			break;
		case 'z':
			x2 = x1 + dz,
			y2 = y1 - 0,
			x4 = x1 + dx,
			y4 = y1 + dy / 2,
			x3 = x4 - dz,
			y3 = y4 + 0;
			break;
		}
		this.bezierCurveToArray(points, x1, y1, x2, y2, x3, y3, x4, y4, a, text);
		x1 = x4, y1 = y4;
	}
	return points;
};
CanvasRenderingContext2D.prototype.draw_way =
function(points) {
	var	xa, ya, xb, yb;
	var	dx, dy, dz, le, x, y, z;
	var	yc, yd;
	var	i = 0, d, text;
	var	streets = [];
	this.strokeStyle = "#AA7";
	this.beginPath();
	this.stroke();
	d = 3;
	xa = points[0].x, ya = points[0].y;
	y = this.canvas.height / 2*2 - 64;
	text = "";
	for(i = d; i <= points.length - d; i ++) {
		if(points[i].text.length > 1)
			text = points[i].text;
		if(i % d != 0)
			continue;
		xb = points[i].x, yb = points[i].y;
		dx = xb - xa, dy = yb - ya;
		le = Math.abs(dx); le = Math.abs(dy) > le ? Math.abs(dy) : le;
		le = le / 32;
		dx /= le, dy /= le;
		x2 = xa + dy, y2 = ya - dx;
		x4 = xa - dy, y4 = ya + dx;
//		z = Math.log(y + 1);
		if(i > d) {
			yc = 23*Math.log(+y2/72);
			yd = 23*Math.log(+y4/72);
			this.beginPath();
			//this.moveTo(x1, y1 + y); this.lineTo(x2, y2 + y);
			//this.moveTo(x3, y3 + y); this.lineTo(x4, y4 + y);
			this.moveTo(x1,  y - yc); this.lineTo(x4, y - yd);
//		this.ellipse(x, this.canvas.height - z * 75, 50 / z, 5 / z, 0, 0, Math.PI * 2, false);
			if("" != text && !streets[text])
				this.fillText(text, x1, y - 300),
				streets[text] = true;
			this.stroke();
			text = "";
		}
		x1 = x2, y1 = y2;
		x3 = x4, y3 = y4;
		xa = xb, ya = yb;
	}
};
//////////////////////////////////////////////////////////////////////////////

// Рисуем небо:    контекст, часы, месяц, яркость
CanvasRenderingContext2D.prototype.sky =
function(hour, month, bright) {
	function gradient(from, last, seek) {
		return {
			r	:from.r + (last.r - from.r) * seek,
			g	:from.g + (last.g - from.g) * seek,
			b	:from.b + (last.b - from.b) * seek
		}
	}
	var	seasons = [
			{ sky:{ day:{ r:224, g:240, b:255 }, night:{ r:32, g:48, b:128 }, morning:{ r:176, g:192, b:192 }, evening:{ r:192, g:160, b:128 } } }	// winter
		,	{ sky:{ day:{ r:240, g:248, b:248 }, night:{ r:48, g:64, b:128 }, morning:{ r:184, g:184, b:192 }, evening:{ r:160, g:192, b:128 } } }	// spring
		,	{ sky:{ day:{ r:255, g:255, b:224 }, night:{ r:64, g:96, b:128 }, morning:{ r:192, g:176, b:160 }, evening:{ r:192, g:160, b:128 } } }	// summer
		,	{ sky:{ day:{ r:248, g:255, b:240 }, night:{ r:48, g:64, b:128 }, morning:{ r:184, g:184, b:192 }, evening:{ r:192, g:128, b:96 } } }	// autumn
		];
	var	sunrise = Math.sin((month + 2) * Math.PI / 12) * 2 + 4;
	var	sunset = Math.sin((month + 2) * Math.PI / 12) * 2 + 18;
	var	quarter = Math.floor((month + 11) % 12 / 3);
	var	quartnext = Math.floor(month % 12 / 3);
	var	zenith = (Math.sin((month - 1) * Math.PI / 12) + 1) * (this.canvas.height * 3 / 8);	// Высота солнца в зените сезона
	var	sun_x = (Math.sin(hour * Math.PI / 12) + 1) * this.canvas.width / 2;
	var	sun_y = Math.cos(hour * Math.PI / 12) * zenith + this.canvas.height * 2 / 3;
	var	moon_x = (-Math.sin(hour * Math.PI / 12) + 1) * this.canvas.width / 2;
	var	moon_y = (-Math.cos(hour * Math.PI / 12) + 7 / 5) * this.canvas.width / 2;
	var	rgb, morning, day, evening, night, text, width;
	var	season = seasons[quarter];
	var	seasonext = seasons[quartnext];
	morning = gradient(season.sky.morning, seasonext.sky.morning, (month + 11) % 3 / 3);
	day = gradient(season.sky.day, seasonext.sky.day, (month + 11) % 3 / 3);
	evening = gradient(season.sky.evening, seasonext.sky.evening, (month + 11) % 3 / 3);
	night = gradient(season.sky.night, seasonext.sky.night, (month + 11) % 3 / 3);
	if(hour > sunset || hour < sunrise)
		rgb = night;
	else {
		rgb = day;
		if(hour < sunrise + 2)	// Два часа до утра
			if(hour < sunrise + 1)	// За час до рассвета
				rgb = gradient(night, morning, (hour - sunrise));
			else			// Утро переходит в день
				rgb = gradient(morning, rgb, (hour - sunrise - 1));
		if(hour > sunset - 2)	// Два часа до вечера
			if(hour > sunset - 1)	// Вечер переходит в ночь
				rgb = gradient(evening, night, (hour - (sunset - 1)));
			else			// За час до заката
				rgb = gradient(rgb, evening, (hour - (sunset - 2)));
	}
	bright = 95;
	rgb = gradient(night, rgb, bright / 100);
	this.beginPath();
	this.fillStyle = "rgba("+[Math.floor(rgb.r), Math.floor(rgb.g), Math.floor(rgb.b)].join()+",100)";
	this.fillRect(0, 0, this.canvas.width, this.canvas.height);
	this.closePath();
	this.beginPath();
	//ctx.strokeStyle = sun_y > 0 ? "rgba(64,64,"+Math.floor(92+bright)+",100)" : "rgba("+[r,g,b].join()+",100)";
	this.fillStyle = "rgba(" + [Math.floor(255*bright/100),Math.floor(255*bright/100),0*192*bright/100].join() + ",1)";
	this.ellipse(sun_x, sun_y, zenith / 6, zenith / 6, 0, Math.PI * 2, 0, false);
	text = "" + (Math.floor(hour) % 24) + ":" + ("0" + (Math.floor(hour * 60) % 60)).substr(-2);
	width = this.measureText(text);
	this.strokeText(text, (sun_x < this.canvas.width / 2 ? sun_x : sun_x - width.width), sun_y + zenith / 5);
	this.closePath();
	this.stroke();
	this.fill();
	this.beginPath();
	this.fillStyle = "white";
	this.ellipse(moon_x, moon_y, this.canvas.height / 16, this.canvas.height / 16, 0, Math.PI * 2, 0, false);
	this.closePath();
	this.fill();
	Environment["Солнце"] = {
		position	:{
			x	:sun_x,
			y	:sun_y
		}
	};
	Environment["Луна"] = {
		position	:{
			x	:moon_x,
			y	:moon_y
		}
	};
	//man.members.lHandX = sun_x, man.members.lHandY = sun_y,
	//man.members.rHandX = sun_x, man.members.rHandY = sun_y;
/*	if(man.position.x -164 > sun_x)
		man.step = -180 -20;
	else
	if(man.position.x +164 < sun_x)
		man.step = +180 +20;
	else
		man.step += man.step > 180 ? -360 : man.step < -180 ? +360 : 0;
*/}
// Рисуем облако:  контекст, облако, позиция, ветер, капли
function actor_cloud(cnv, ctx, cloud, x0, windy, d, text, xm, ym, yy) {
	var	x, y, z, w, h, n, d, r1, r2, r3;
	var	i, a, x1, y1, x2, y2, x3, y3, r, r0, tmp;
	var	a1, a2, arr = [];
	var	tx, ty, tw = 0, th, tl = 0;
	if(text) {
		th = parseInt(ctx.font, 10);
		for(tmp in text) {
			w = ctx.measureText(text[tmp]).width;
			if(tw < w)
				tw = w;
			if(tl < text[tmp].length)
				tl = text[tmp].length;
		}
		cloud.x = xm,
		cloud.y = yy,
		cloud.z = 0;
		cloud.w = tw * 0.75,
		cloud.h = (th * text.length) / 3;
		cloud.r1 = 2,
		cloud.r2 = 10,
		cloud.r3 = 20;
		cloud.n = Math.floor(tl);
		cloud.x1 = 0,
		cloud.y1 = 0;
	}
	cloud.x1 += Math.random() * windy / 10 + windy / 5;
	cloud.y1 += Math.random() * windy / 10 + windy / 5;
	cloud.x1 = cloud.x1 % (windy / 5 + 1), cloud.y1 = cloud.y1 % (windy / 5 + 1);
	x = cloud.x + cloud.x1, y = cloud.y + cloud.y1, z = 1 + Math.log(cloud.z + 1);
	w = cloud.w / z, h = cloud.h / z, n = cloud.n;
	r1 = cloud.r1 / z, r2 = cloud.r2 / z, r3 = cloud.r3 / z;
	cloud.x -= windy / z;
	x += x0;
	n *= 3; a1 = 2 * Math.PI / n / n;
	a2 = Math.PI / 3;
	for(i = 0; i < n; ++ i) {
		a = 2 * Math.PI * i / n + Math.random() * a1 + a2;
		r = [r3, r3, r2][i % 3] + Math.random() * r1;
		x1 = Math.cos(a) * (w + r), y1 = Math.sin(a) * (h + r);
		arr.push({x: x1, y: y1});
	}
	ctx.beginPath();
	ctx.fillStyle = "white";
	ctx.strokeStyle = "white";
	ctx.closePath();
	ctx.stroke();
	ctx.beginPath();
	tmp = arr.length - 1;
	if(text) {
		ctx.setLineDash([4,1]);
		ctx.moveTo(xm, ym);
	} else
		ctx.moveTo(x+arr[tmp].x, y+arr[tmp].y);
	while(arr.length) {
		tmp = arr.shift();
		x1 = tmp.x, y1 = tmp.y;
		tmp = arr.shift();
		x2 = tmp.x, y2 = tmp.y;
		tmp = arr.shift();
		x3 = tmp.x, y3 = tmp.y;
		ctx.bezierCurveTo(x + x1, y + y1, x + x2, y + y2, x + x3, y + y3);
	}
	ctx.closePath();
	ctx.lineWidth = 3 / z;
	ctx.fillStyle = "rgba("+[Math.floor(255/(d/5+1)),Math.floor(255/(d/4+1)),255].join(",")+",1)";
	ctx.fill();
	ctx.strokeStyle = '#0000ff';
	ctx.stroke();
	ctx.beginPath();
	ctx.strokeStyle = "rgba(64,160,255," + (d/100) + ")";
	ctx.lineWidth = 2 / z;
	if(d > 10) {
		for(i = 0; i < 10; ++ i) {
			ctx.setLineDash([Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)]);
			x1 = Math.random() + x + w * i / 10;
			//if(Math.random() * d > i / 2)
				ctx.moveTo(x1, y + h + Math.random() * h),
				ctx.lineTo(x1 + 1 * windy, cnv.height);
		}
	}
	ctx.stroke();
	ctx.setLineDash([]);
	if(text) {
		ctx.fillStyle = "black";
		tx = xm, ty = cloud.y - text.length * th / 2 + th / 2;
		tmp = ctx.font;
		ctx.font = "bold " + tmp;
		for(i = 0; i < text.length; ++ i) {
			ctx.fillText(text[i], tx - ctx.measureText(text[i]).width / 2, ty);
			ty += th + Math.random() * 2;
			tx += 2 - Math.random() * 3;
			ctx.font = tmp;
		}
		ctx.stroke();
		return (i + 2.5) * th;
	}
}
var	hour = 0;
var	phase = 0, dir = 360 + 30;
//
var	chatArea	= null;

var	FANTASEUR =
function() {
	var	actor_name	= null;
	var	actor_type	= null;
	var	actor_list	= {};
	var	actor_stock	= {
		"ПОГОДА"
		:function() {
		}
	};
	///////////////////////////////////////////////
	this.canvas = document.createElement("canvas");
	this.canvas.width = 640;
	this.canvas.height = 480;
	this.context = this.canvas.getContext("2D");
	///////////////////////////////////////////////
	this.actor = function(name) {	return (name ? actor_name = name : actor_name);	};
	this.variety = function(id) {
	};
};
// Вася Пупкин
// ВасяПупкин
// ВасяП.
// В.П.
var	subj = {};
var	Nick = "";
function parse() {
	var	text, nick, music, cnt, counter = 0;
	var	name = "";
	var	replay = "";
	while(text = chatArea.readString()) {
		music = text.split(":");
		if(music[0] == "Музыка") {
			Audio.load(music[1]);
		} else
		if(":" == text.substr(-1) && text.length > 1) {				// Using Character
			text = text.substr(0, text.length - 1);
			nick = text.isNickOf(subj);
			if(!nick) {
				nick = text.toName();
				subj[nick] = newMan();
				subj[nick].chatArea = document.createElement("textarea");
				subj[nick].playing = playing;
				subj[nick].iSleep = 0;
				subj[nick].nick = nick;
				subj[nick].parent = subj;
				subj[nick].acts = [];
				subj[nick].chatArea.rows = 12,
				subj[nick].chatArea.cols = 40;
				subj[nick].path.points = way;
				document.getElementById("ChatAreas").appendChild(subj[nick].chatArea);
			}
			name = nick;
		} else
		if(isFinite(text)) {
			cnt = +text;
			if(name != "" && (name in subj))
				while(-- cnt > 0)
					subj[nick].chatArea.value += replay + "\r1\r";
		} else
		if(name != "" && (name in subj)) {
			subj[nick].chatArea.value += text + "\r";
			replay = text;
		}
		if(nick in subj)
			subj[nick].chatArea.selectionStart = 1,
			subj[nick].chatArea.selectionEnd = 1;
	}
}

function playing(ctx) {
	var	text, nick, words, act, acts, tmp, wait, target, novel = false;
	if(this.iSleep == 0) {
		while(text = this.chatArea.readString()) {
			if(isFinite(text)) {
				this.iSleep = +text;
				break;
			} else
			if(text.match(/\d+:\d\d/)) {
				target = parseInt(text, 10) * 60 + parseInt(text.substr(3), 10);
				if(target / 60 > hour) {
					this.chatArea.readString(true);
					this.chatArea.readString(true);
					return;
				}
			} else
			if(text.match(/^[a-z_а-я]/)) {
				novel = "..." == text.substr(-3);
				if(novel)
					this.novel = [],
					text = text.substr(0, text.length - 3);
				acts = text.split(/,\s*/);
				while(acts.length > 0) {
					words = acts.shift().split(/\s+/);
					nick = "";
					if(words[0].match(/^[a-z_а-я]/))
						act = words.shift();
					else
						act = "";
					while(words[0] && words[0].match(/^[A-ZА-Я]/))
						nick += words.shift();
					words = words.join(" ");
					tmp = nick.isNickOf(this.parent);
					if(!tmp && (nick in Environment)) {
						target = Environment[nick];
					} else
					if(tmp)
						nick = tmp,
						target = this.parent[nick];
					else
						wait = true;
					if(act in this) {
						if(novel)
							this.novel.push({
								act	:act,
								target	:target
							});
						if(this[act](target) || wait)
							return this.chatArea.readString(true);
					}
				}
			} else
			if("\"\"" == text.charAt(0) + text.substr(-1)) {
				if(text == "\"\"")
					tips = [];
				else
				if(tips.length > 0) {
					tips[0].text += "\t" + text.substr(1, text.length - 2);
					tips[0].z = 250;
				} else {
					tmp = ctx.cloud_create(0, 0);
					tmp.y = -ctx.canvas.height / 12,
					tmp.z = 250;
					tmp.text = "\t" + text.substr(1, text.length - 2);
					tips = [tmp];
				}
			} else
			if("..." == text)
				this.text = [];
			else
			if("..." == text.substr(-3))
				this.text = [this.nick, text.substr(0, text.length - 3)];
			else
				this.text.push(text);
		}
	} else
		-- this.iSleep;
}
var	Storage;
var	way;
var	iSecond = -1;
var	isStep = true;
var	cld, cld1;
var	blobs = [];
var	tips = [];	// Облака авторского текста
var	lyrics = [];	// Облака актёрского текста
function main(cnv, ctx) {
	var	text = ["Василий Пупкин", "(((((((Люблю прыгать", "целый день!)))))))", ":-D"];
	if(!cnv) {
		Storage = window.localStorage;
		setTimeout(initMusic, 9876);
		chatArea = document.getElementById("ChatArea"),
		chatAreas = document.getElementById("ChatAreas"),
		cnv = document.getElementsByTagName("canvas")[0],
		ctx = cnv.getContext("2d");
		if(Storage["Optionals"])
			document.getElementById("Optional").value = Storage["Optionals"];
		chatArea.value = chatArea.value.replace(/\[([1-9])\]/, function(str, x) {
				return document.getElementById("Optional").value.split(/\s+/)[(+x + 9) % 10];
			}
		);
		chatArea.selectionStart = 1,
		chatArea.selectionEnd = 1;
		//chatArea.readString = readString;
		for(var i = 0; i < 10; ++ i)
			//clouds.push(actor_cloud_new(cnv.width/2, cnv.height, 0));
			clouds.push(ctx.cloud_create(0, 0));
		ctx.font = "" + Math.abs(cnv.height / 30) + "px Courier New";
		way = ctx.build_way(ways[0]);
		/*cld = ctx.cloud_create(0, 0);
		cld.y = 0,
		cld.z = 200;
		cld1 = ctx.cloud_create(0, 0);
		cld1.y = 0,
		cld1.z = 200;*/
		chatArea.focus();
		parse();//speaking();
	}
/*	cnv.addEventListener("mousemove", function(e) {
		//var pageCrds = '('+ e.pageX +', '+ e.pageY +')',
		man.members.lHandX = e.clientX,
		man.members.lHandY = e.clientY;
		man.members.rHandX = e.clientX,
		man.members.rHandY = e.clientY;
	});
*/	ctx.sky(hour % 24, 6, 100);
	ctx.fillStyle = "grey"; ctx.hiway();
	ctx.fillStyle = "white"; ctx.fill();
	//for(var i = 0; i < clouds.length; ++ i)		ctx.cloud(clouds[i], 0, 0, 0);
	ctx.draw_way(way);
	ctx.house(100, hour / 24, 5);
	var	time = new Date();
	var	flag = time.getSeconds() == iSecond;
	blobs = [];
	lyrics = [].concat(clouds).concat(tips);
	var	st = document.getElementById("Status");
	var	sc = 0;
	st.innerHTML = "";
	for(i in subj) {
	//	subj[i].position.x = 0;
	//	subj[i].position.z = hour / 2;
		ctx.stickMan(subj[i], lyrics);
		if(st.rows.length < 1)
			st.insertRow(0);
		st.rows[0].insertCell(sc);
		st.rows[0].cells[sc].innerHTML = "<b>" + i + "</b>";
		var	sr = 1;
		for(j in subj[i]) {
			if("?" == j.substr(-1)) {
				if(st.rows.length <= sr)
					st.insertRow(sr);
				st.rows[sr].insertCell(sc);
				if(subj[i][j]())
					st.rows[sr].cells[sc].style = "opacity:0.9";
				else
					st.rows[sr].cells[sc].style = "opacity:0.2";
				st.rows[sr].cells[sc].innerHTML = j;
				sr ++;
			}
		}
		if(isStep)
			subj[i].playing(ctx);
		else
			for(j in subj[i].novel)
				subj[i][subj[i].novel[j].act](subj[i].novel[j].target);
		sc ++;
	}
	for(i = 0; i < lyrics.length; ++ i)
		ctx.cloud(lyrics[i], blobs);
	if(!flag)
		iSecond = time.getSeconds(),
		isStep = true;
	else
		isStep = false;
	text = ["", "(Люблю я целый","день прыгать)"];
	//ctx.cloud([],0,0,0, [].concat(text), 320, 120, 100, blobs);
	//man.left = dir >= 360 ? phase + 180 : phase - 540;
	//man.rift = dir >= 360 ? phase + 180 + 180 : phase - 540 - 180;
	phase = (phase % 360 + dir + 360) % 360
	hour += 4/9/10*2;
	///man.position.z += 1;
	setTimeout(this.main.bind(this, cnv, ctx), 100);
}
</script>
</head>
<body onload='main()'>
<table id=Status style='position:absolute; left:8px; top:8px; opacity:1.25'></table>
<canvas width=640 height=480></canvas>
<textarea cols=40 rows=12 id=ChatArea>
Музыка:[1]
Василий Пупкин:
стоит
избегает И.И.И.
быстрее, быстрее, быстрее, быстрее
1
обратно
ловит Солнце...
быстрее
6:40
Иди за мной!...
:)
ловит И.И.И....
стоит
7:15
"Прогулки"
Будь рядом!
ловит И.И.И., прыгает
2
Не отставай!
"по "Млечному путю""
прыгает, избегает И.И.И., быстрее, быстрее
3
:-D...
обратно
ловит Солнце...
3
""
стоит
За мной!...
Иван Иваныч Иванов:
ждет В.П., догоняет В.П., быстрее, быстрее, быстрее, быстрее
слушает В.П., стоит
догоняет В.П....
ждёт В.П.
прыгает
15
догоняет В.П., быстрее...
5
</textarea>
<span id=ChatAreas></span>
<input id=Optional oninput='Storage["Optionals"] = this.value' type=text size=80 value='anar.mod oblaka.mod //mod.haxor.fi/mods/Vogue/mod.axel_f' />
<p style=text-align:center><a href='#' onclick='chrome.tabs.create({url:"chrome://flags/#autoplay-policy"})' title='Switch to "No gesture"'>Sound is fails</a></p>
<p style=text-align:center><a href='http://github.com/Alikberov'>Visit me now</a><br />&copy;2018 Alikberov</p>
</body>
